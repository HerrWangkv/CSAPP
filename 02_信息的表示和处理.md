三种重要的数字表示：
- 无符号(unsigned):基于传统的二进制表示法，表示大于或等于0的数字
- 补码(two's-complement):表示有符号整数
- 浮点数(floating-point):表示实数的科学计数法的以二为基数的版本

整数的表示虽然只能编码一个较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的：
```cpp
cout << 500*400*300*200 << endl;//溢出，输出负数，但交换顺序不改变结果
cout << (3.14 + 1e20) - 1e20 << endl;//输出0
cout << (1e20 - 1e20) + 3.14 << endl;//输出3.14
```

# 1 信息存储
机器级程序将存储器视为一个非常大的字节(1byte = 8bit)数组，称为[虚拟存储器 virtal memory](./01_计算机系统漫游.md#73-虚拟存储器-virtual-memory)。存储器的每个字节都由一个唯一的数字来标记，称为它的**地址 address**。所有可能地址的集合称为**虚拟地址空间 virtual address space**。每个进程看到的虚拟地址空间都是统一的。
## 1.1 十六进制(hexadecimal)表示法
C语言中以0x或0X开头的数字常量被认为是十六进制的值。

每个十六进制位可以转化成4位二进制

## 1.2 字
每台计算机都有一个**字长 word size**，指明整数和指针数据的标称大小。每个虚拟地址对应的存储空间是一个字节，但虚拟地址是用一个字(word)来编码的。假设一个机器字长为w，则虚拟地址的范围是0~2^w-1。因此程序最多访问2^w个字节。

## 1.3 数据大小
32位系统及64位系统中，C语言中数字数据类型的字节数：
![C语言中数字数据类型的字节数](Images/2_1.png)

## 1.4 寻址和字节顺序
跨越多字节的程序对象被存储为连续的字节序列，而该对象的地址为所使用字节中最小的地址。假设一个类型为int的变量x的地址为0x100，表示地址表达式&x的值为0x100，x的4个字节被存储在0x100, 0x101, 0x102, 0x103。

两种存储多字节对象的方法：
- 小端法(little endian)：最低有效字节在最前面
- 大端法(big endian)：最高有效字节在最前面

以0x01234567为例：
![大小端](Images/2_2.png)

## 1.5 表示字符串
文本数据使用某种标准编码以具有更强的平台独立性

- 生成一张ASCII表(使用单字节表示字符)：
    ```shell
    $ man ascii
    ```
- 文字编码的Unicode标准

    ASCII字符集适合于编码英语文档，汉语等语言的文档需要用Unicode编码，使用32位(4个字节)来表示字符

## 1.6 表示代码
二进制代码是不兼容的。同一个程序在不同系统的机器上编译生成的机器代码(二进制代码)是不兼容的。

## 1.8 C语言中的位级运算
```|```：按位或

```&```：按位与

```～```：按位取反

```^```：按位异或

掩码：如```x & 0xFF```生成一个由```x```的最低有效字节组成的值。如：```x = 0x89ABCDEF; x & 0xFF=0x000000EF```。而如果想要一个表示全1的掩码，一般直接用```~0```,以提高代码可移植性。

## 1.9 C语言中的逻辑运算
```||```：逻辑或

```&&```：逻辑与

```!```：逻辑非

## 1.10 C语言中的移位运算符
- 左移```<<```
  
    ```x<<k```表示x向左移动k位，丢弃最高的k位，并在最后补k个0
- 右移```>>```

    1. 逻辑右移：```x>>k```表示在x左端补k个0，并删除最后k位。即$[0,...0,x_{n-1},x_{n-2}...,x_k]$
    2. 算术右移：```x>>k```表示在左端补k个最高有效位的值，并删除最后k位。即$[x_{n-1},...,x_{n-1},x_{n-1},x_{n-2},...,x_k]$

C语言中：对于无符号数据，右移必须是逻辑的；而对于有符号数据，右移在几乎所有编译器中都定义为算术右移。

当移动的位数k较大时，实际上的位移量是k%w位(实际为类似取余运算的取模运算)，其中w代表机器的[字长](#12-字)

# 2 整数表示
## 2.1 整型数据类型
C语言中要求下列数据类型至少具有这样的取值范围：
![图2-10](Images/2_3.png)

## 2.2 无符号数的编码
