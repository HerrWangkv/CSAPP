### 3.1
0x100 <br>M[0x104]=0xAB<br> 0x108<br> M[0x100]=0xFF<br> M[0x104]=0xAB<br> M[0x10C]=0x11<br> M[0x108]=0x13<br> M[0x100]=0xFF<br> M[0x10C]=0x11

### 3.2 
mov1<br>
movw<br>
movb<br>
movb<br>
movq<br>
movw<br>

### 3.3
%ebx为4字节，而地址一般为64位，故(%ebx)无法表示间接寻址<br>
%rax为四字，应该用movq<br>
内存间的移动需要2条语句<br>
不存在\%sl<br>
立即数不能作为目的操作数<br>
%rdx为四字，而%eax为双字<br>
%si为1字

### 3.4
movsbl (%rdi), %eax<br>
movl %eax, (%rsi)<br>

movsbl (%rdi), %eax<br>
movl %eax, (%rsi)<br>

movzbl (%rdi), %eax //movzbq也可，但只传输32位更快(高32位自动置0)<br>
movq %rax, (%rsi)<br>

movl (%rdi), %eax<br>
movb %al, (%rsi)<br>

movl (%rdi), %eax<br>
movb %al, (%rsi)<br>

movsbw (%rdi), %ax<br>
movb %ax, (%rsi)<br>

注意：
- 括号内永远只能是完整寄存器
- char是1字节，short是2字节，int是4字节
- 强制转换是发生零扩展还是符号扩展只取决于源操作数的类型，见[扩展一个数字的位表示](../02_信息的表示和处理.md#2.6-扩展一个数字的位表示)
- 对于寄存器而言，如果生成32位数据和64位数据结果相同(如零扩展)，为速度考虑，常只生成32位，因为高32位会自动置0
- 在源操作数长度大于目的操作数时一般先将整个源操作数复制过来，再直接移动所需的目的操作数长度

### 3.5
```cpp
void decode1(long *xp, long *yp, long *zp) {
    long t1, t2, t3;
    t1 = *xp;
    t2 = *yp;
    t3 = *zp;
    *yp = t1;
    *zp = t2;
    *xp = t3;
    return;//最后一句可不写
}
```

### 3.6
注：第一行题干%ax改成%rax<br>
x+6<br>
x+y<br>
x+4y<br>
9x+7<br>
4y+10<br>
x+2y+9

### 3.7
5 * x + 2 * y + 8 * z

### 3.8
0x100 0x100<br>
0x108 0xA8<br>
0x118 0x110<br>
0x110 0x14<br>
%rcx 0x0<br>
%rax 0xFD<br>
注意：
- 立即数的书写方式是‘\$’后面跟一个用标准C表示法表示的整数
- 此题中所有指令后缀都是q，所以不用担心溢出
- ```Imm(r)```之类的操作数中的Imm都是十进制
